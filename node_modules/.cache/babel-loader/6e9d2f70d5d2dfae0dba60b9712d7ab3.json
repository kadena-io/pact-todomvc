{"ast":null,"code":"var blake = require('blakejs');\n\nvar nacl = require('tweetnacl');\n\nvar binToHex = function (s) {\n  var constructor = s.constructor.name || null;\n\n  if (constructor !== 'Uint8Array') {\n    throw new TypeError('Expected Uint8Array');\n  }\n\n  return Buffer.from(s).toString('hex');\n};\n\nvar hexToBin = function (h) {\n  if (typeof h !== 'string') {\n    throw new TypeError(\"Expected string: \" + h);\n  }\n\n  return new Uint8Array(Buffer.from(h, 'hex'));\n};\n\nvar hashBin = function (s) {\n  return blake.blake2b(s);\n};\n\nvar hash = function (s) {\n  return binToHex(hashBin(s));\n};\n\nvar genKeyPair = function () {\n  var kp = nacl.sign.keyPair();\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return {\n    \"publicKey\": pubKey,\n    \"secretKey\": secKey\n  };\n};\n\nvar toTweetNaclSecretKey = function (keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  return hexToBin(keyPair.secretKey + keyPair.publicKey);\n};\n\nvar sign = function (msg, keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  var hshBin = hashBin(msg);\n  var hsh = binToHex(hshBin);\n  var sigBin = nacl.sign.detached(hshBin, toTweetNaclSecretKey(keyPair));\n  return {\n    \"hash\": hsh,\n    \"sig\": binToHex(sigBin),\n    \"pubKey\": keyPair.publicKey\n  };\n};\n\nvar pullSigAndPubKey = function (s) {\n  if (!s.hasOwnProperty(\"pubKey\") || !s.hasOwnProperty(\"sig\")) {\n    throw new TypeError(\"Expected to find keys of name 'sig' and 'pubKey' in \" + JSON.stringify(s));\n  }\n\n  return {\n    \"sig\": s.sig,\n    \"pubKey\": s.pubKey\n  };\n};\n\nvar pullAndCheckHashs = function (sigs) {\n  var hsh = sigs[0].hash;\n\n  for (var i = 1; i < sigs.length; i++) {\n    if (sigs[i].hash !== hsh) {\n      throw new Error('Sigs for different hashes found: ' + JSON.stringify(sigs));\n    }\n  }\n\n  return hsh;\n};\n\nvar mkSingleCmd = function (sigs, cmd) {\n  // Lower level API constructor\n  // Formats a single command from its parts:\n  //   sigs: a list of {hash, pubKey, sig}\n  //   cmd: the stringified json blob used to create the hash\n  // Throws `PactError` if an issue is found\n  if (!Array.isArray(sigs)) {\n    throw new TypeError('Expected the first argument (sigs) to be an array of sigs');\n  }\n\n  if (typeof cmd !== 'string') {\n    throw new TypeError('Expected the second argument (cmd) to be a string');\n  }\n\n  return {\n    \"hash\": pullAndCheckHashs(sigs),\n    \"sigs\": sigs.map(pullSigAndPubKey),\n    \"cmd\": cmd\n  };\n};\n\nvar mkPublicSend = function (cmds) {\n  // Lower level API constructor\n  // Does the last level of wrapping\n  if (Array.isArray(cmds)) {\n    return {\n      \"cmds\": cmds\n    };\n  } else {\n    return {\n      \"cmds\": [cmds]\n    };\n  }\n};\n\nvar simpleExecCommand = function (keyPairs, nonce, pactCode, envData) {\n  // Input: eithe a single or array of keyPairs, a nonce, pactCode, and an envData object\n  // Output: a correctly formatted JSON exec msg for pact, send it to /api/public/send\n  // Throws PactError on maleformed inputs\n  if (typeof nonce !== 'string') {\n    throw new TypeError('nonce must be a string: ' + JSON.stringify(nonce));\n  }\n\n  if (typeof pactCode !== 'string') {\n    throw new TypeError('pactCode must be a string: ' + JSON.stringify(pactCode));\n  }\n\n  var cmd = JSON.stringify({\n    \"nonce\": nonce,\n    \"payload\": {\n      \"exec\": {\n        \"code\": pactCode,\n        \"data\": envData || {}\n      }\n    }\n  });\n  var sigs = [];\n\n  if (Array.isArray(keyPairs)) {\n    sigs = keyPairs.map(function (kp) {\n      return sign(cmd, kp);\n    });\n  } else {\n    sigs = [sign(cmd, keyPairs)];\n  }\n\n  var hsh = pullAndCheckHashs(sigs);\n  return mkPublicSend({\n    \"hash\": hsh,\n    \"sigs\": sigs.map(pullSigAndPubKey),\n    \"cmd\": cmd\n  });\n};\n\nvar unique = function (arr) {\n  var n = {},\n      r = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (!n[arr[i]]) {\n      n[arr[i]] = true;\n      r.push(arr[i]);\n    }\n  }\n\n  return r;\n};\n\nvar simplePollRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    \"requestKeys\": rks\n  };\n};\n\nvar simpleListenRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    \"requestKey\": rks[0]\n  };\n};\n\nvar mkExp = function (pgmName) {\n  if (typeof pgmName !== 'string') {\n    throw new TypeError('pgmName must be a string: ' + JSON.stringify(pgmName));\n  }\n\n  return '(' + pgmName + ' ' + Array.prototype.slice.call(arguments, 1).map(JSON.stringify).join(' ') + ')';\n};\n\nmodule.exports = {\n  crypto: {\n    binToHex: binToHex,\n    hexToBin: hexToBin,\n    hash: hash,\n    genKeyPair: genKeyPair,\n    sign: sign,\n    toTweetNaclSecretKey: toTweetNaclSecretKey\n  },\n  api: {\n    mkSingleCmd: mkSingleCmd,\n    mkPublicSend: mkPublicSend\n  },\n  lang: {\n    mkExp: mkExp\n  },\n  simple: {\n    exec: {\n      createCommand: simpleExecCommand,\n      createPollRequest: simplePollRequestFromExec,\n      createListenRequest: simpleListenRequestFromExec\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}