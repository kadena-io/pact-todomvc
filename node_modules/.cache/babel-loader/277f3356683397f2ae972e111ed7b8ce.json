{"ast":null,"code":"/** pact-lang-api.js\n * Exports functions to support Pact API calls.\n * Author: Will Martino, Hee Kyun Yun, Stuart Popejoy\n * Supports: Pact API 3.0 v1\n */\nconst blake = require(\"blakejs\");\n\nconst nacl = require(\"tweetnacl\");\n\nconst base64url = require(\"base64-url\");\n/**\n * Convert binary to hex.\n * @param s {Uint8Array} - binary value\n * @return {string} hex string\n */\n\n\nvar binToHex = function (s) {\n  var constructor = s.constructor.name || null;\n\n  if (constructor !== \"Uint8Array\") {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n\n  return Buffer.from(s).toString(\"hex\");\n};\n/**\n * Convert hex string to binary.\n * @param s {string} - hex string\n * @return {Uint8Array} binary value\n */\n\n\nvar hexToBin = function (h) {\n  if (typeof h !== \"string\") {\n    throw new TypeError(\"Expected string: \" + h);\n  }\n\n  return new Uint8Array(Buffer.from(h, \"hex\"));\n};\n/**\n * Perform blake2b256 hashing.\n */\n\n\nvar hashBin = function (s) {\n  return blake.blake2b(s, null, 32);\n};\n/**\n * Perform blake2b256 hashing, encoded as unescaped base64url.\n */\n\n\nvar hash = function (s) {\n  return base64UrlEncode(hashBin(s));\n};\n/**\n * Hash string as unescaped base64url.\n */\n\n\nvar base64UrlEncode = function (s) {\n  return base64url.escape(base64url.encode(s));\n};\n/**\n * Generate a random ED25519 keypair.\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\n\n\nvar genKeyPair = function () {\n  var kp = nacl.sign.keyPair();\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return {\n    publicKey: pubKey,\n    secretKey: secKey\n  };\n};\n\nvar toTweetNaclSecretKey = function (keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  return hexToBin(keyPair.secretKey + keyPair.publicKey);\n};\n/**\n * Sign data using key pair.\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {object} with \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key value.\n */\n\n\nvar sign = function (msg, keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n  var sigBin = nacl.sign.detached(hshBin, toTweetNaclSecretKey(keyPair));\n  return {\n    hash: hsh,\n    sig: binToHex(sigBin),\n    pubKey: keyPair.publicKey\n  };\n};\n\nvar pullSigAndPubKey = function (s) {\n  if (!s.hasOwnProperty(\"pubKey\") || !s.hasOwnProperty(\"sig\")) {\n    throw new TypeError(\"Expected to find keys of name 'sig' and 'pubKey' in \" + JSON.stringify(s));\n  }\n\n  return {\n    sig: s.sig,\n    pubKey: s.pubKey\n  };\n};\n\nvar pullSig = function (s) {\n  if (!s.hasOwnProperty(\"sig\")) {\n    throw new TypeError(\"Expected to find keys of name 'sig' in \" + JSON.stringify(s));\n  }\n\n  return {\n    sig: s.sig\n  };\n};\n\nvar pullPubKeyAndAddr = function (s) {\n  if (!s.hasOwnProperty(\"pubKey\")) {\n    throw new TypeError(\"Expected to find keys of name 'pubKey' in \" + JSON.stringify(s));\n  }\n\n  return {\n    pubKey: s.pubKey,\n    addr: s.pubKey,\n    scheme: \"ED25519\"\n  };\n};\n\nvar pullAndCheckHashs = function (sigs) {\n  var hsh = sigs[0].hash;\n\n  for (var i = 1; i < sigs.length; i++) {\n    if (sigs[i].hash !== hsh) {\n      throw new Error(\"Sigs for different hashes found: \" + JSON.stringify(sigs));\n    }\n  }\n\n  return hsh;\n};\n/**\n * Prepare an ExecMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair\n * @param nonce {string} - nonce value for ensuring unique hash\n * @param pactCode {string} - pact code to execute\n * @param envData {object} - JSON message data for command\n * @param meta {object} - meta information, see mkMeta\n * @return valid pact API command for send or local use.\n */\n\n\nvar prepareExecCmd = function (keyPairs, nonce, pactCode, envData, meta) {\n  enforceType(nonce, \"string\", \"nonce\");\n  enforceType(pactCode, \"string\", \"pactCode\");\n  var kpArray = asArray(keyPairs);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    nonce: nonce,\n    payload: {\n      exec: {\n        code: pactCode,\n        data: envData || {}\n      }\n    },\n    signers: signers,\n    meta: meta\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = kpArray.map(function (kp) {\n    return sign(cmd, kp);\n  });\n  return mkSingleCmd(sigs, cmd);\n};\n/**\n * Makes a single command given signed data.\n * @param sigs {array} - array of signature objects, see 'sign'\n * @param cmd {string} - stringified JSON blob used to create hash\n * @return valid Pact API command for send or local use.\n */\n\n\nvar mkSingleCmd = function (sigs, cmd) {\n  enforceArray(sigs, \"sigs\");\n  enforceType(cmd, \"string\", \"cmd\");\n  return {\n    hash: pullAndCheckHashs(sigs),\n    sigs: sigs.map(pullSig),\n    cmd: cmd\n  };\n};\n/**\n * Makes outer wrapper for a 'send' endpoint.\n * @param {array or object} cmds - one or an array of commands, see mkSingleCmd\n */\n\n\nvar mkPublicSend = function (cmds) {\n  return {\n    cmds: asArray(cmds)\n  };\n};\n/**\n * Make an ED25519 \"signer\" array element for inclusion in a Pact payload.\n * @param {object} kp - a ED25519 keypair\n * @return {object} an object with pubKey, addr and scheme fields.\n */\n\n\nvar mkSigner = function (kp) {\n  return {\n    pubKey: kp.publicKey,\n    addr: kp.publicKey,\n    scheme: \"ED25519\"\n  };\n};\n\nvar asArray = function (singleOrArray) {\n  if (Array.isArray(singleOrArray)) {\n    return singleOrArray;\n  } else {\n    return [singleOrArray];\n  }\n};\n\nvar enforceType = function (val, type, msg) {\n  if (typeof val !== type) {\n    throw new TypeError(msg + \" must be a \" + type + \": \" + JSON.stringify(value));\n  }\n};\n\nvar enforceArray = function (val, msg) {\n  if (!Array.isArray(val)) {\n    throw new TypeError(msg + \" must be an array: \" + JSON.stringify(value));\n  }\n};\n/**\n * Make a full 'send' endpoint exec command. See 'prepareExecCmd' for parameters.\n */\n\n\nvar simpleExecCommand = function (keyPairs, nonce, pactCode, envData, meta) {\n  return mkPublicSend(prepareExecCmd(keyPairs, nonce, pactCode, envData, meta));\n};\n\nvar unique = function (arr) {\n  var n = {},\n      r = [];\n\n  for (var i = 0; i < arr.length; i++) var hsh = eckHashs(sigs);\n\n  return mkPublicSend({\n    hash: hsh,\n    sigs: sigs.map(pullSigAndPubKey),\n    cmd: cmd\n  });\n};\n\nvar unique = function (arr) {\n  var n = {},\n      r = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (!n[arr[i]]) {\n      n[arr[i]] = true;\n      r.push(arr[i]);\n    }\n  }\n\n  return r;\n};\n/**\n * Given an exec 'send' message, prepare a message for 'poll' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'\n * @return {object} with \"requestKeys\" for polling.\n */\n\n\nvar simplePollRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    requestKeys: rks\n  };\n};\n/**\n * Given an exec 'send' message, prepare a message for 'listen' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'. Only takes first element.\n * @return {object} with \"requestKey\" for polling.\n */\n\n\nvar simpleListenRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    listen: rks[0]\n  };\n};\n/**\n * Variadic function to form a lisp s-expression application.\n * Encases arguments in parens and intercalates with a space.\n */\n\n\nvar mkExp = function (pgmName) {\n  enforceType(pgmName, \"string\", \"pgmName\");\n  return \"(\" + pgmName + \" \" + Array.prototype.slice.call(arguments, 1).map(JSON.stringify).join(\" \") + \")\";\n};\n/**\n * Prepare a chainweb-style meta payload.\n * @param sender {string} gas account\n * @param chainId {string} chain identifier\n * @param gasPrice {number} desired gas price\n * @param gasLimit {number} desired gas limit\n * @return {object} of arguments, type-checked and properly named.\n */\n\n\nvar mkMeta = function (sender, chainId, gasPrice, gasLimit) {\n  enforceType(sender, \"string\", \"sender\");\n  enforceType(chainId, \"string\", \"chainId\");\n  enforceType(gasPrice, \"number\", \"gasPrice\");\n  enforceType(gasPrice, \"number\", \"gasLimit\");\n  return {\n    gasLimit: gasLimit,\n    chainId: chainId,\n    gasPrice: gasPrice,\n    sender: sender\n  };\n};\n/**\n * Formats ExecCmd into api request object\n */\n\n\nvar mkReq = function (cmd) {\n  return {\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    body: JSON.stringify(cmd)\n  };\n};\n/**\n * A Command Object\n * @typedef {Object} execCmd\n * @property pactCode {string} - pact code to execute\n * @property keyPairs {array or object} - array or single ED25519 keypair\n * @property nonce {string} - nonce value, default at current time\n * @property envData {object} - JSON message data for command, default at empty obj\n * @property meta {object} - meta information, see mkMeta\n * @property apiHost {string} - host running Pact server\n */\n\n/**\n * Sends Pact command to a running Pact server and retrieves tx result.\n * @param {execCmd} sendCmd\n * @return {object} - Request key of the tx received from pact server.\n */\n\n\nconst fetchSend = async function ({\n  pactCode,\n  keyPairs,\n  nonce = new Date().toISOString(),\n  envData = {},\n  meta = mkMeta(\"\", \"\", 0, 0),\n  apiHost\n}) {\n  const reqParams = [\"pactCode\", \"keyPairs\", \"apiHost\"];\n  reqParams.forEach(arg => {\n    if (!arguments[0][arg]) throw new Error(\"Pact.sendCommand(): No \".concat(arg, \" provided\"));\n  });\n  const cmd = simpleExecCommand(keyPairs, nonce, pactCode, envData, meta);\n  const txRes = await fetch(\"\".concat(apiHost, \"/api/v1/send\"), mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n};\n/**\n * Sends Local Pact command to a running Pact server and retrieves local tx result.\n * @param {execCmd} localCmd\n * @return {object} - tx result received from pact server.\n */\n\n\nconst fetchLocal = async function ({\n  pactCode,\n  keyPairs,\n  nonce = new Date().toISOString(),\n  envData = {},\n  meta = mkMeta(\"\", \"\", 0, 0),\n  apiHost\n}) {\n  const reqParams = [\"pactCode\", \"keyPairs\", \"apiHost\"];\n  reqParams.forEach(arg => {\n    if (!arguments[0][arg]) throw new Error(\"Pact.sendCommand(): No \".concat(arg, \" provided\"));\n  });\n  const cmd = prepareExecCmd(keyPairs, nonce, pactCode, envData, meta);\n  const txRes = await fetch(\"\".concat(apiHost, \"/api/v1/local\"), mkReq(cmd));\n  const tx = await txRes.json();\n  return tx.result;\n};\n/**\n * Request poll Pact command to a running Pact server and retrieves tx result.\n * @param {Object} pollCmd\n * @property rks {array} - Array of request keys of tx to poll.\n * @property apiHost {string} - host running Pact server\n * @return {object} - Array of tx request keys and tx results from pact server.\n */\n\n\nconst fetchPoll = async function ({\n  rks,\n  apiHost\n}) {\n  const cmd = {\n    requestKeys: rks\n  };\n  const res = await fetch(\"\".concat(apiHost, \"/api/v1/poll\"), mkReq(cmd));\n  const resJSON = await res.json();\n  return Object.values(resJSON).map(res => {\n    return {\n      reqKey: res.reqKey,\n      result: res.result\n    };\n  });\n};\n/**\n * Request listen Pact command to a running Pact server and retrieves tx result.\n * @param {Object} listenCmd\n * @property rk {string} - reqest key of tx to listen.\n * @property apiHost {string} - host running Pact server\n * @return {object} - Object containing tx result from pact server\n */\n\n\nconst fetchListen = async function ({\n  rk,\n  apiHost\n}) {\n  const cmd = {\n    listen: rk\n  };\n  const res = await fetch(\"\".concat(apiHost, \"/api/v1/listen\"), mkReq(cmd));\n  const resJSON = await res.json();\n  return resJSON.result;\n};\n\nmodule.exports = {\n  crypto: {\n    binToHex: binToHex,\n    hexToBin: hexToBin,\n    base64UrlEncode: base64UrlEncode,\n    hash: hash,\n    genKeyPair: genKeyPair,\n    sign: sign,\n    toTweetNaclSecretKey: toTweetNaclSecretKey\n  },\n  api: {\n    prepareExecCmd: prepareExecCmd,\n    mkSingleCmd: mkSingleCmd,\n    mkPublicSend: mkPublicSend\n  },\n  lang: {\n    mkExp: mkExp,\n    mkMeta: mkMeta\n  },\n  simple: {\n    exec: {\n      createCommand: simpleExecCommand,\n      createLocalCommand: prepareExecCmd,\n      createPollRequest: simplePollRequestFromExec,\n      createListenRequest: simpleListenRequestFromExec\n    }\n  },\n  fetch: {\n    send: fetchSend,\n    local: fetchLocal,\n    poll: fetchPoll,\n    listen: fetchListen\n  }\n};","map":null,"metadata":{},"sourceType":"script"}